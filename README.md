# Лабораторная работа 2. Разработка библиотеки mySimpleComputer. Оперативная память, регистр флагов, декодирование операций.
## 1) Разработайте функции по взаимодействию с оперативной памятью, управлению регистром флагов и кодированию/декодированию команд:
#### a. int sc_memoryInit () – инициализирует оперативную память Simple Computer, задавая всем еѐ ячейкам нулевые значения. В качестве «оперативной памяти» используется массив целых чисел, определенный статически в рамках библиотеки. Размер массива равен 100 элементам.
#### b. int sc_memorySet (int address, int value) – задает значение указанной ячейки памяти как value. Если адрес выходит за допустимые границы, то устанавливается флаг «выход за границы памяти» и работа функции прекращается с ошибкой;
#### c. int sc_memoryGet (int address, int * value) – возвращает значение указанной ячейки памяти в value. Если адрес выходит за допустимые границы, то устанавливается флаг «выход за границы памяти» и работа функции прекращается с ошибкой. Значение value в этом случае не изменяется.
#### d. int sc_memorySave (char * filename) – сохраняет содержимое памяти в файл в бинарном виде (используя функцию write или fwrite);
#### e. int sc_memoryLoad (char * filename) – загружает из указанного файла содержимое оперативной памяти (используя функцию read или fread);
#### f. int sc_regInit (void) – инициализирует регистр флагов нулевым значением;
#### g. int sc_regSet (int register, int value) – устанавливает значение указанного регистра флагов. Для номеров регистров флагов должны использоваться маски, задаваемые макросами (#define). Если указан недопустимый номер регистра или некорректное значение, то функция завершается с ошибкой.
#### h. int sc_regGet (int register, int * value) – возвращает значение указанного флага. Если указан недопустимый номер регистра, то функция завершается с ошибкой.
#### i. int sc_commandEncode (int command, int operand, int * value) – кодирует команду с указанным номером и операндом и помещает результат в value. Если указаны неправильные значения для команды или операнда, то функция завершается с ошибкой. В этом случае значение value не изменяется.
#### j. int sc_commandDecode (int value, int * command, int * operand) – декодирует значение как команду Simple Computer. Если декодирование невозможно, то устанавливается флаг «ошибочная команда» и функция завершается с ошибкой.
## 2) Оформите разработанные функции как статическую библиотеку. Подготовьте заголовочный файл для неё.
# Лабораторная работа 3. Консоль управления моделью Simple Computer. Текстовая часть.
## 1) Разработать следующие функции:
#### a. int mt_clrscr (void)- производит очистку и перемещение курсора в левый верхний угол экрана;
#### b. int mt_gotoXY (int, int) - перемещает курсор в указанную позицию. Первый параметр номер строки, второй - номер столбца;
#### c. int mt_getscreensize (int * rows, int * cols) - определяет размер экрана терминала (количество строк и столбцов);
#### d. int mt_setfgcolor (enum colors) - устанавливает цвет последующих выводимых символов. В качестве параметра передаѐтся константа из созданного Вами перечислимого типа colors, описывающего цвета терминала;
#### e. int mt_setbgcolor (enum colors) - устанавливает цвет фона последующих выводимых символов. В качестве параметра передаѐтся константа из созданного Вами перечислимого типа colors, описывающего цвета терминала.
#### P.S. Все функции возвращают 0 в случае успешного выполнения и -1 в случае ошибки. В качестве терминала используется стандартный поток вывода.
## 2) Оформите разработанные функции как статическую библиотеку myTerm. Подготовьте заголовочный файл для неё.
## 3) Разработайте программу, выводящую на экран содержимое оперативной памяти, регистров и назначения клавиш.
# Лабораторная работа 4. Консоль управления моделью Simple Computer. Псевдографика. «Большие символы».
## 1) Разработать следующие функции:
#### a. int bc_printA (char * str) - выводит строку символов с использованием дополнительной кодировочной таблицы;
#### b. int bc_box(int x1, int y1, int x2, int y2) - выводит на экран псевдографическую рамку, в которой левый верхний угол располагается в строке x1 и столбце y1, а еѐ ширина и высота равна y2 столбцов и x2 строк;
#### c. int bc_printbigchar (int [2], int x, int y, enum color, enum color) - выводит на экран "большой символ" размером восемь строк на восемь столбцов, левый верхний угол которого располагается в строке x и столбце y. Третий и четвѐртый параметры определяют цвет и фон выводимых символов. "Символ" выводится исходя из значений массива целых чисел следующим образом. В первой строке выводится 8 младших бит первого числа, во второй следующие 8, в третьей и 4 следующие. В 5 строке выводятся 8 младших бит второго числа и т.д. При этом если значение бита = 0, то выводится символ "пробел", иначе - символ, закрашивающий знакоместо (ACS_CKBOARD);
#### d. int bc_setbigcharpos (int * big, int x, int y, int value) - устанавливает значение знакоместа "большого символа" в строке x и столбце y в значение value;
#### e. int bc_getbigcharpos(int * big, int x, int y, int *value) - возвращает значение позиции в "большом символе" в строке x и столбце y;
#### f. int bc_bigcharwrite (int fd, int * big, int count) - записывает заданное число "больших символов" в файл. Формат записи определяется пользователем;
#### g. int bc_bigcharread (int fd, int * big, int need_count, int * count) - считывает из файла заданное количество "больших символов". Третий параметр указывает адрес переменной, в которую помещается количество считанных символов или 0, в случае ошибки.
## 2) Доработать интерфейс из Лабораторной работы 3: Нарисованные рамки и вывод большими символами содержимое ячейки, на которую указывает программный "курсор".
# Лабораторная работа 5. Консоль управления моделью Simple Computer. Клавиатура. Обработка нажатия клавиш. Неканонический режим работы терминала.
## 1) Разработать следующие функции:
#### a. int rk_readkey (enum keys *) - анализирующую последовательность символов (возвращаемых функцией read при чтении с терминала) и возвращающую первую клавишу, которую нажал пользователь. В качестве параметра в функцию передаѐтся адрес переменной, в которую возвращается номер нажатой (enum keys – перечисление распознаваемых клавиш);
#### b. int rk_mytermsave (void) - сохраняет текущие параметры терминала;
#### c. int rk_mytermrestore (void) - восстанавливает сохранѐнные параметры терминала.
#### d. int rk_mytermregime (int regime, int vtime, int vmin, int echo, int sigint) - переключает терминала между режимами. Для неканонического режима используются значения второго и последующего параметров.
## 2) Оформите разработанные функции как статическую библиотеку myReadkey. Подготовьте заголовочный файл для неѐ.
## 3) Доработать интерфейс из Лабораторной работы 3: Добавить возможность задавать значения ячейкам оперативной памяти, регистрам и обработку клавиш "l", "s".
# Лабораторная работа 6. Подсистема прерываний ЭВМ. Сигналы и их обработка.
## 1) Доработать консоль Simple Computer. 
#### Создать обработчик прерываний от системного таймера так, чтобы при каждом его срабатывании при нулевом значении флага «игнорирование сигналов системного таймера» значение регистра "instructionCounter" увеличивалось на 1, а при поступлении сигнала SIGUSR1 состояние Simple Computer возвращалось в исходное. Обработка нажатых клавиш осуществляется только в случае, если сигналы от таймера не игнорируются.
